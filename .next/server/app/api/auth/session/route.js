(()=>{var e={};e.id=745,e.ids=[745],e.modules={96330:e=>{"use strict";e.exports=require("@prisma/client")},10846:e=>{"use strict";e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},44870:e=>{"use strict";e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},29294:e=>{"use strict";e.exports=require("next/dist/server/app-render/work-async-storage.external.js")},63033:e=>{"use strict";e.exports=require("next/dist/server/app-render/work-unit-async-storage.external.js")},85340:(e,t,r)=>{"use strict";r.r(t),r.d(t,{patchFetch:()=>w,routeModule:()=>p,serverHooks:()=>g,workAsyncStorage:()=>d,workUnitAsyncStorage:()=>h});var s={};r.r(s),r.d(s,{GET:()=>l});var a=r(42706),n=r(28203),o=r(45994),i=r(39187),u=r(45369),c=r(44512);async function l(e){try{let e=await (0,c.UL)(),t=e.get("session-token")?.value;if(!t)return i.NextResponse.json({user:null,session:null});let r=await u.U.getSession(t);if(!r)return i.NextResponse.json({user:null,session:null});return i.NextResponse.json(r)}catch(e){return console.error("Error getting session:",e),i.NextResponse.json({user:null,session:null})}}let p=new a.AppRouteRouteModule({definition:{kind:n.RouteKind.APP_ROUTE,page:"/api/auth/session/route",pathname:"/api/auth/session",filename:"route",bundlePath:"app/api/auth/session/route"},resolvedPagePath:"/workspace/app/api/auth/session/route.ts",nextConfigOutput:"standalone",userland:s}),{workAsyncStorage:d,workUnitAsyncStorage:h,serverHooks:g}=p;function w(){return(0,o.patchFetch)({workAsyncStorage:d,workUnitAsyncStorage:h})}},96487:()=>{},78335:()=>{},45369:(e,t,r)=>{"use strict";r.d(t,{U:()=>u});var s=r(96330);let a=globalThis.prisma??new s.PrismaClient,n=process.env.GITLAB_HOST||"https://gitlab.sonod.tech",o=process.env.GITLAB_CLIENT_ID,i=process.env.GITLAB_CLIENT_SECRET;process.env.NEXTAUTH_SECRET;class u{static getAuthUrl(){let e=new URLSearchParams({client_id:o,redirect_uri:`${process.env.NEXTAUTH_URL}/api/auth/callback/gitlab`,response_type:"code",scope:"read_user read_api api",state:this.generateState()});return`${n}/oauth/authorize?${e.toString()}`}static async exchangeCodeForToken(e){let t=await fetch(`${n}/oauth/token`,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({client_id:o,client_secret:i,code:e,grant_type:"authorization_code",redirect_uri:`${process.env.NEXTAUTH_URL}/api/auth/callback/gitlab`})});if(!t.ok)throw Error("Failed to exchange code for token");return t.json()}static async getUserInfo(e){let t=await fetch(`${n}/api/v4/user`,{headers:{Authorization:`Bearer ${e}`}});if(!t.ok)throw Error("Failed to fetch user info");return t.json()}static async createOrUpdateUser(e){let t={gitlabId:e.id.toString(),name:e.name,email:e.email,image:e.avatar_url,role:"USER"};return await a.user.upsert({where:{gitlabId:e.id.toString()},update:t,create:t})}static generateState(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}static async getSession(e){try{let t=await a.user.findUnique({where:{id:e}});if(!t)return null;return{user:t,expires:new Date(Date.now()+2592e6).toISOString()}}catch(e){return console.error("Error getting session:",e),null}}}}};var t=require("../../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),s=t.X(0,[989,452,512],()=>r(85340));module.exports=s})();